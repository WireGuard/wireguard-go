package fec

import "fmt"

// FECAlgorithmType defines the type of FEC algorithm.
type FECAlgorithmType int

const (
	None FECAlgorithmType = iota
	XOR
	ReedSolomon
	RaptorQ
)

func (f FECAlgorithmType) String() string {
	switch f {
	case None:
		return "None"
	case XOR:
		return "XOR"
	case ReedSolomon:
		return "ReedSolomon"
	case RaptorQ:
		return "RaptorQ"
	default:
		return fmt.Sprintf("Unknown(%d)", f)
	}
}

// Packet represents a data packet.
type Packet []byte

// FECProtector defines the interface for FEC operations.
type FECProtector interface {
	// Encode takes a set of source packets and returns a set of FEC-encoded packets.
	// For systematic codes (like RS, XOR), this output includes the original source packets plus repair packets.
	// For non-systematic codes, it might just be repair packets or a transformed set.
	Encode(sourcePackets []Packet) (outputPackets []Packet, err error)

	// Decode takes a set of received packets (which could be a mix of source and repair, or just repair)
	// and attempts to reconstruct the original source packets.
	// Packets should be provided as a map where the key is their original index or symbol ID.
	// For ReedSolomon and XOR, nil entries in a slice can represent missing packets at specific indices.
	// For RaptorQ, symbol IDs are used.
	// This method needs to be flexible or have variants for different FEC types if a single signature is too awkward.
	// Let's refine this: Decode expects a slice of packets, where nil indicates a missing packet for RS/XOR.
	// For RaptorQ, this slice might represent symbols with associated IDs not directly tied to slice index.
	//
	// Revised Decode for RS/XOR: input is a slice of length (data+parity) or (data+1 for xor).
	// nil entries are erasures.
	//
	// For RaptorQ, the Decode process is typically stateful (add symbols one by one).
	// So, a simple Decode(packets) might not be best for RaptorQ.
	//
	// Let's assume for now:
	// Decode takes whatever packets were received (some might be nil for erasure codes if using a fixed-size slice input).
	// It returns the K original source packets.
	Decode(receivedPackets []Packet) (reconstructedSourcePackets []Packet, err error)

	Algorithm() FECAlgorithmType

	// NumDataShards returns the number of data shards expected by the protector.
	NumDataShards() int

	// NumParityShards returns the number of parity shards generated by the protector.
	NumParityShards() int

	// TotalShards returns the total number of shards (data + parity).
	TotalShards() int
}
